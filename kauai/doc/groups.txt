/***************************************************************************

	Collection classes:  General List (DynamicArray), Allocated List (AllocatedArray),
	General Group (GeneralGroup),  Allocated Group (AllocatedGroup),
	General String Table (StringTable_GST), Allocated String Table (AllocatedStringTable).

***************************************************************************/


/****************************************
	Types
****************************************/

	class DynamicArray;
	typedef class DynamicArray *PDynamicArray;
		A general purpose dynamically allocated array class.  Data
		elements must be all the same size.  Clients may assume the
		data elements are contiguous.  I.e., if you have a pointer to
		the iv'th element, incrementing the pointer will give you a pointer
		to the (iv+1)th element.

	class AllocatedArray;
	typedef class AllocatedArray *PAllocatedArray;
		A list where indices don't change when items are added
		or deleted.  Clients may assume data elements are contiguous.
		Note, however, that an element may be free.  Call FFree to
		determine if a particular item is free.

	class GeneralGroup;
	typedef class GeneralGroup *PGeneralGroup;
		A group: a collection of data objects of possibly different
		sizes.  If all your elements are the same size, use a DynamicArray.

	class AllocatedGroup;
	typedef class AllocatedGroup *PAllocatedGroup;
		A group where indices don't change when items are added or
		deleted.  Entries can be free.  Call FFree to determine
		if an entry is free.

	class StringTable_GST;
	typedef class StringTable_GST *PStringTable_GST;
		A string table.  Can also store a fixed size piece of "extra"
		data for each string.

	class AllocatedStringTable;
	typedef class AllocatedStringTable *PAllocatedStringTable;
		An allocated string table.  Like a string table, but indices
		don't change when strings are added or deleted.  Entries
		can be free.  Call FFree to determine if an entry is free.


/****************************************
	Constants
****************************************/

	fgrpNil - default options
	fgrpShrink - shrink space allocated if its more than needed


/****************************************
	Common methods
****************************************/

	PDynamicArray   DynamicArray::PglNew(long cb, long cvInit = 0);
	PAllocatedArray   AllocatedArray::PalNew(long cb, long cvInit = 0);
	PGeneralGroup   GeneralGroup::PggNew(long cvInit = 0, long cbInit = 0);
	PAllocatedGroup   AllocatedGroup::PagNew(long cvInit = 0, long cbInit = 0);
	PStringTable_GST StringTable_GST::PgstNew(long cbExtra, long cstzInit = 0, long cchInit = 0);
	PAllocatedStringTable AllocatedStringTable::PastNew(long cbExtra, long cstzInit = 0, long cchInit = 0);
		These are static methods (not invoked from an object) that
		allocate a new object of the appropriate class.  For DynamicArray and
		AllocatedArray classes, cb is the size of the elements and cvInit is the
		number of elements to reserve space for.  For StringTable_GST and AllocatedStringTable, cbExtra
		is the amount of extra data associated with each string.  For
		GeneralGroup, AllocatedGroup, StringTable_GST and AllocatedStringTable, cvInit/cstzInit are how many entries to make room
		for and cbInit/cchInit are the total number of bytes to allow for
		these entries.  These values are as in FEnsureSpace.

	PDynamicArray   DynamicArray::PglRead(PFileObject pfil, FP fp, long cb, short *pbo, short *posk);
	PAllocatedArray   AllocatedArray::PalRead(PFileObject pfil, FP fp, long cb, short *pbo, short *posk);
	PGeneralGroup   GeneralGroup::PggRead(PFileObject pfil, FP fp, long cb, short *pbo, short *posk);
	PAllocatedGroup   AllocatedGroup::PagRead(PFileObject pfil, FP fp, long cb, short *pbo, short *posk);
	PStringTable_GST StringTable_GST::PgstRead(PFileObject pfil, FP fp, long cb, short *pbo, short *posk);
	PAllocatedStringTable AllocatedStringTable::PastRead(PFileObject pfil, FP fp, long cb, short *pbo, short *posk);
		Static methods to read an object from disk.  pbo and posk may be
		nil.  *pbo is set to the byte order of the object and *posk is
		set to the osk (Operating System Kind) that wrote the object.
		Use *pbo to do byte swapping after reading and *posk to do string
		translation after reading.

	bool  DynamicArray::FWrite(PFileObject pfil, FP fp, long *pcb = pvNil,
			short bo = kboCur, short osk = koskCur);
	bool  AllocatedArray::FWrite(PFileObject pfil, FP fp, long *pcb = pvNil,
			short bo = kboCur, short osk = koskCur);
	bool  GeneralGroup::FWrite(PFileObject pfil, FP fp, long *pcb = pvNil,
			short bo = kboCur, short osk = koskCur);
	bool  AllocatedGroup::FWrite(PFileObject pfil, FP fp, long *pcb = pvNil,
			short bo = kboCur, short osk = koskCur);
	bool StringTable_GST::FWrite(PFileObject pfil, FP fp, long *pcb = pvNil,
			short bo = kboCur, short osk = koskCur);
	bool AllocatedStringTable::FWrite(PFileObject pfil, FP fp, long *pcb = pvNil,
			short bo = kboCur, short osk = koskCur);
		Write the object to disk.  If pcb is not nil, sets *pcb to the
		amount of space used.  If bo and osk are specified as something
		different from kboCur and koskCur, these will adjust the byte
		order and/or osk before writing the data.  Obviously, client
		managed data is not adjusted.  REVIEW shonk: should strings
		in an StringTable_GST/AllocatedStringTable be handled automatically.

	long  DynamicArray::CbOnFile(void);
	long  AllocatedArray::CbOnFile(void);
	long  GeneralGroup::CbOnFile(void);
	long  AllocatedGroup::CbOnFile(void);
	long StringTable_GST::CbOnFile(void);
	long AllocatedStringTable::CbOnFile(void);
		Returns the amount of space required to write the object to
		disk.

	long  DynamicArray::IvMac(void);
	long  AllocatedArray::IvMac(void);
	long  GeneralGroup::IvMac(void);
	long  AllocatedGroup::IvMac(void);
	long StringTable_GST::IstzMac(void);
	long AllocatedStringTable::IstzMac(void);
		Returns the number of active items.  For AllocatedArray, AllocatedGroup and AllocatedStringTable, this
		is the lim of legal indices, not the number of non-free
		entries.

	void  DynamicArray::Delete(long iv);
	void  AllocatedArray::Delete(long iv);
	void  GeneralGroup::Delete(long iv);
	void  AllocatedGroup::Delete(long iv);
	void StringTable_GST::Delete(long istz);
	void AllocatedStringTable::Delete(long istz);
		Deletes the indicated element.  For AllocatedArray, AllocatedGroup and AllocatedStringTable, indices of
		remaining items don't change (ie, a hole is created).  For the other
		classes, items with larger indices "slide down" to fill the hole.

	void *DynamicArray::QvGet(long iv);
	void *AllocatedArray::QvGet(long iv);
	void *GeneralGroup::QvGet(long iv);
	void *AllocatedGroup::QvGet(long iv);
		Returns a volatile pointer to the element.  For GPs, iv must
		be less than IvMac().  For DynamicArray and AllocatedArray, iv must be <= IMac()
		( == is allowed for convenience; don't access it!).  For AllocatedArray and AllocatedGroup,
		the element may be free (call FFree to check).

	void *DynamicArray::PvLock(long iv);
	void *AllocatedArray::PvLock(long iv);
	void *GeneralGroup::PvLock(long iv);
	void *AllocatedGroup::PvLock(long iv);
		Locks the data and returns a pointer to the iv'th element.
		Same restrictions on iv as for QvGet(iv).

	void DynamicArray::Lock(void);
	void AllocatedArray::Lock(void);
	void GeneralGroup::Lock(void);
	void AllocatedGroup::Lock(void);
		Locks the data.

	void DynamicArray::Unlock(void);
	void AllocatedArray::Unlock(void);
	void GeneralGroup::Unlock(void);
	void AllocatedGroup::Unlock(void);
		Unlocks the data.  Balances a call to PvLock() or Lock().
		Locking is nestable.

	void DynamicArray::Get(long iv, void *pv);
	void AllocatedArray::Get(long iv, void *pv);
	void GeneralGroup::Get(long iv, void *pv);
	void AllocatedGroup::Get(long iv, void *pv);
		Copies the iv'th item to *pv.  Assumes pv points to a block
		large enough to hold the item.  iv must be less than IvMac().
		For GeneralGroup and AllocatedGroup, GetRgb is more useful.

	void DynamicArray::Put(long iv, void *pv);
	void AllocatedArray::Put(long iv, void *pv);
	void GeneralGroup::Put(long iv, void *pv);
	void AllocatedGroup::Put(long iv, void *pv);
		The opposite of Get(iv, pv).  Copies data from *pv to the iv'th
		element.  For GeneralGroup and AllocatedGroup, see FPut and PutRgb.

	bool DynamicArray::FAdd(void *pv, long *piv);
	bool AllocatedArray::FAdd(void *pv, long *piv);
	bool GeneralGroup::FAdd(long cb, void *pv, long *piv);
	bool AllocatedGroup::FAdd(long cb, void *pv, long *piv);
		Add a new element to the class.  If piv is not nil, *piv is
		set to the index of the new item.  For DynamicArray and GeneralGroup, the new item
		is always the last.  For AllocatedArray and AllocatedGroup, the first free slot is used.


/****************************************
	List specific methods
****************************************/

	long DynamicArray::CbEntry(void);
		Returns the size of each element of the list (as specified
		in PglNew or as read from file in PglRead.

	bool DynamicArray::FSetIvMac(long ivMacNew);
		Changes the number of items active in the list.  Rarely used.

	bool DynamicArray::FEnsureSpace(long cvAdd, short grfgrp);
		Ensure that there is room for at least cvAdd additional items.
		To close up the list, use FEnsureSpace(0, fgrpShrink).

	bool DynamicArray::FInsert(long iv, void *pv);
		Inserts a new item into the list at location iv.  Parameter
		iv must be less than or equal to IvMac().  Moves later items
		up to make room.

	void Move(long ivSrc, long ivDst)
		Moves the element at ivSrc to the ivDst position, shifting
		everything in between.

	bool DynamicArray::FPush(void *pv);
		Appends the item to the end of the list.  Equivalent to
		FAdd(pv, pvNil).

	bool DynamicArray::FPop(void *pv = pvNil);
		If the list is empty, returns false (indicating stack underflow).
		Otherwise, fetches the last item (if pv is not nil), deletes
		the item, and returns true.

	bool DynamicArray::FEnqueue(void *pv)
		Equivalent to FInsert(0, pv).

	bool DynamicArray::FDequeue(void *pv = pvNil);
		Equivalent to FPop(pv).


/****************************************
	Allocated List specific methods
****************************************/

	long AllocatedArray::CbEntry(void);
		Returns the size of each element of the list (as specified
		in PalNew or as read from file in PalRead.

	bool AllocatedArray::FEnsureSpace(long cvAdd, short grfgrp);
		Ensure that there is room for at least cvAdd additional items.
		To close up the allocated list use FEnsureSpace(0, fgrpShrink).

	bool AllocatedArray::FFree(long iv);
		Indicates whether item iv is free.  (This is fast).  iv should
		be less than IvMac().


/****************************************
	Group specific methods
****************************************/

	bool GeneralGroup::FEnsureSpace(long cvAdd, long cbAdd, short grfgrp);
	bool AllocatedGroup::FEnsureSpace(long cvAdd, long cbAdd, short grfgrp);
		Make sure there is room for at least cvAdd additional items,
		using cbAdd bytes of space.  To close up the group
		use FEnsureSpace(0, 0, fgrpShrink).

	bool GeneralGroup::FInsert(long iv, long cb, void *pv);
		Inserts an item of size cb into the group.  pv may be nil.

	bool GeneralGroup::FPut(long iv, long cb, void *pv);
	bool AllocatedGroup::FPut(long iv, long cb, void *pv);
		Replaces the item with new data of the given length.  pv may
		be nil, in which case this effectively resizes the element.

	long GeneralGroup::Cb(long iv);
	long AllocatedGroup::Cb(long iv);
		Returns the length of the item.

	void GeneralGroup::GetRgb(long iv, long bv, long cb, void *pv);
	void AllocatedGroup::GetRgb(long iv, long bv, long cb, void *pv);
		Fetches a section of data from the given element.  bv is the offset
		of the data into the element, cb is the amount of data to copy
		and pv is the destination.

	void GeneralGroup::PutRgb(long iv, long bv, long cb, void *pv);
	void AllocatedGroup::PutRgb(long iv, long bv, long cb, void *pv);
		The inverse of GetRgb.

	void GeneralGroup::DeleteRgb(long iv, long bv, long cb);
	void AllocatedGroup::DeleteRgb(long iv, long bv, long cb);
		Deletes a portion of the given element.  Deletes bytes [bv, bv+cb).

	bool GeneralGroup::FInsertRgb(long iv, long bv, long cb, void *pv);
	bool AllocatedGroup::FInsertRgb(long iv, long bv, long cb, void *pv);
		Inserts cb new bytes before byte bv of the element.  pv may be nil.

	bool AllocatedGroup::FFree(long iv);
		Indicates whether item iv is free.  (This is fast).  iv should
		be less than IvMac().


/****************************************
	String Table specific methods
****************************************/

	bool StringTable_GST::FEnsureSpace(long cstzAdd, long cchAdd, short grfgrp);
	bool AllocatedStringTable::FEnsureSpace(long cstzAdd, long cchAdd, short grfgrp);
		Make sure there is room for at least cstzAdd additional strings,
		using cchAdd bytes of space.  To close up the string table
		use FEnsureSpace(0, 0, fgrpShrink).

	bool StringTable_GST::FInsertRgch(long istz, char *prgch, long cch, void *pvExtra);
	bool StringTable_GST::FInsertStz(long istz, char *pstz, void *pvExtra);
	bool StringTable_GST::FInsertSt(long istz, char *pst, void *pvExtra);
	bool StringTable_GST::FInsertSz(long istz, char *psz, void *pvExtra);
		Insert a new string at location istz.  pvExtra may be nil.

	bool StringTable_GST::FAddRgch(char *prgch, long cch, void *pvExtra, long *pistz);
	bool StringTable_GST::FAddStz(char *pstz, void *pvExtra, long *pistz);
	bool StringTable_GST::FAddSt(char *pst, void *pvExtra, long *pistz);
	bool StringTable_GST::FAddSz(char *psz, void *pvExtra, long *pistz);
	bool AllocatedStringTable::FAddRgch(char *prgch, long cch, void *pvExtra, long *pistz);
	bool AllocatedStringTable::FAddStz(char *pstz, void *pvExtra, long *pistz);
	bool AllocatedStringTable::FAddSt(char *pst, void *pvExtra, long *pistz);
	bool AllocatedStringTable::FAddSz(char *psz, void *pvExtra, long *pistz);
		Append a string to the string table.  pistz may be nil.  If not,
		*pistz is set the index of the new string.  pvExtra may be nil.

	void StringTable_GST::GetExtra(long istz, void *pv);
	void AllocatedStringTable::GetExtra(long istz, void *pv);
		Fill pv with the extra data for the string.  Asserts that cbExtra
		is > 0.

	void StringTable_GST::PutExtra(long istz, void *pv);
	void AllocatedStringTable::PutExtra(long istz, void *pv);
		Set the extra data for the string.  Asserts that cbExtra is > 0.

	void StringTable_GST::GetStz(long istz, char *pstz);
	void StringTable_GST::GetSt(long istz, char *pst);
	void StringTable_GST::GetSz(long istz, char *psz);
	void AllocatedStringTable::GetStz(long istz, char *pstz);
	void AllocatedStringTable::GetSt(long istz, char *pst);
	void AllocatedStringTable::GetSz(long istz, char *psz);
		Get the istz'th string.  pstz/pst/psz must point to a buffer at least
		kcbMaxStz/kcbMaxSt/kcbMaxSz bytes long.

	bool StringTable_GST::FPutRgch(long istz, char *prgch, long cch);
	bool StringTable_GST::FPutStz(long istz, char *pstz);
	bool StringTable_GST::FPutSt(long istz, char *pst);
	bool StringTable_GST::FPutSz(long istz, char *psz);
	bool AllocatedStringTable::FPutRgch(long istz, char *prgch, long cch);
	bool AllocatedStringTable::FPutStz(long istz, char *pstz);
	bool AllocatedStringTable::FPutSt(long istz, char *pst);
	bool AllocatedStringTable::FPutSz(long istz, char *psz);
		Replace the istz'th string.

	bool StringTable_GST::FFindStz(char *pstz, long *pistz, ulong grfstb = fstbNil);
	bool StringTable_GST::FFindSt(char *pst, long *pistz, ulong grfstb = fstbNil);
	bool StringTable_GST::FFindSz(char *psz, long *pistz, ulong grfstb = fstbNil);
	bool AllocatedStringTable::FFindStz(char *pstz, long *pistz, ulong grfstb = fstbNil);
	bool AllocatedStringTable::FFindSt(char *pst, long *pistz, ulong grfstb = fstbNil);
	bool AllocatedStringTable::FFindSz(char *psz, long *pistz, ulong grfstb = fstbNil);
		Finds the given string in the string table.  If fstbSorted is specified,
		and this is an StringTable_GST, a binary search is performed.  If the string is
		not found, false is returned.  If the string is not found and this is
		an StringTable_GST and fstbSorted was specified, *pistz will be filled with where
		the string should be inserted to maintain the sorting.  In other cases,
		if the string is not found, *pistz is filled with IstzMac().

	bool AllocatedStringTable::FFree(long istz);
		Indicates whether item istz is free.  (This is fast).  istz should
		be less than IstzMac().

